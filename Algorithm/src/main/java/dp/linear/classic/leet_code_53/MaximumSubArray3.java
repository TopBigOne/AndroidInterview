package dp.linear.classic.leet_code_53;

/**
 * @author : dev
 * @version :
 * @Date :  2022/5/19 14:08
 * @Desc :
 */
public class MaximumSubArray3 {

    public int maxSubArray(int[] nums) {
        // step 1: corner base;
        int len = nums.length;
        int[] dp = new int[len];
        int result = nums[0];
        dp[0] = nums[0];
        // step 2:  core logic；
        for (int i = 1; i < len; i++) {
            // 状态转移方程
            // --------------------------------------------------------------↓
            // 前提：dp[i] ：以下标i结尾，形成的子序列的最大和，
            // 注意： 是以i为结尾；
            // 无论是一维，二维....还是n维度，
            // 譬如： dp[i][j][k][....], 你都需要不遗余力的理解 i，j,k 对应的含义；
            // --------------------------------------------------------------↑
            // dp[i - 1] > 0 ? dp[i - 1] : 0 ,三元运算，主要是判断dp[i-1]是不是大于0
            // 1：要是大于0 ，我们可以选择做累加操作；
            // 2：反之，说明上一个dp[i-1]的子序列之和是小于0 的；我们就选择 0 做累加操作，约等于，什么都不加，
            //    免得让dp[i]的值更小；

            // PS:老铁，你说对不对？ 我+了你，是为了让自己变得更加强大，而不是让你来稀释我的成分；所以，你不行，我就不+了，离你远一些；
            //    只有这样，我才能在data 结尾处，得到自己的最值；

            // 下边这行代码，使用Math.max(),虽然高效，但是不好理解状态的转移过程的变化过程，面试，装B用, 可以憋着笑解释，我这行代码，有多高效；
            // dp[i] = nums[i] + (Math.max(dp[i - 1], 0));

            // 仔细品味，状态的转移过程，由上一个dp[i-1],选择+，或者不+，推导出dp[i],
            // 部分最优====>得到全局中的最优；
            dp[i] = nums[i] + (dp[i - 1] > 0 ? dp[i - 1] : 0);

            // 在每次循环中，通过dp[i].得到最大值；当然，你可以在写一个for循环，做个操作
            // 那样的话，代码的可读性，会变得更高一些；随意，随意，随意！
            result = Math.max(result, dp[i]);
        }
        return result;
    }

}
